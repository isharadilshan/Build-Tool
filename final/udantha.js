#!/usr/bin/env node
/**
 * @author AppX Team
 * @description Build FEF bundle targeting platform
 * @summary Reason for node script: to support multiple platforms and use existing npm modules
 */
//Configs
const Config = {
    FEF_FOLDER: __dirname + '/src/fef',
    SRC_FOLDER: __dirname + '/src/common',
    DIST_FOLDER: __dirname + '/dist',
    COMMON_FOLDER_NAME: `common-autogenerated-25012019`
};

const { lstatSync, readdirSync, existsSync, readFileSync, writeFileSync, mkdir, createWriteStream } = require('fs');
const { join, relative } = require('path');
const { ncp } = require('ncp');
const { spawn } = require('child_process');
const util = require('util');
const rimraf = require("rimraf");
const glob = require("glob");
const chalk = require("chalk");
const archiver = require('archiver');

const Builder = {

    /**
     * Entry function
     */
    archive: function () {
        //copy folders
        Log.done('Starting FEF build process...')
        Promise.all(this.copyToDesignFolders())
            .then(success => {
                Log.done('Copying completed!')
                Log.info('Creating the zip file.')
                return Builder.createZip();
            })
            .then(() => {
                Log.completed('Success! Archive.zip created in "dist" folder.')
            })
            .catch(error => {
                Log.error(`!PROCESS HALTED!. Please rectify the error. ${error}`)
            })
    },

    /**
     * Copy common to design folders
     */
    copyToDesignFolders: function () {
        let copyingProcesses = [];
        //find all design folders, loop
        readdirSync(Config.FEF_FOLDER).forEach(folderName => {
            copyingProcesses.push(Builder.processCommonCopying(folderName));
        });

        return copyingProcesses;

    },

    processCommonCopying: async function (folderName) {
        try {
            //take in only fef folders
            let designFolderPath = join(Config.FEF_FOLDER, folderName);
            if (lstatSync(designFolderPath).isDirectory() && folderName.charAt(0) === '$') {
                //where to copy to
                let targetFolder = join(designFolderPath, 'source', 'includes', Config.COMMON_FOLDER_NAME);
                //delete existing common folder
                if (existsSync(targetFolder)) {
                    await util.promisify(rimraf)(targetFolder);
                    //@todo remove below
                    await util.promisify(rimraf)(join(designFolderPath, 'source', 'includes', 'common'));
                }
                //copy common folder into design
                Log.info(`-> copying common to ${folderName}`)
                await util.promisify(ncp)(Config.SRC_FOLDER, targetFolder);
                Log.info(`-> completed copying to ${folderName}`);
                //add file paths to include
                return Builder.addCommonsToIncludes(designFolderPath, targetFolder, folderName);
            }
        } catch (error) {
            throw new Error(`!Error processing ${folderName} - ${error}`)
        }
    },

    addCommonsToIncludes: function (designFolderPath, commonFolderPath, designFolderName) {
        const pathToIncludesFile = join(designFolderPath, 'source', 'server', 'includes.json');
        try {
            var includesContent = JSON.parse(readFileSync(pathToIncludesFile));
        } catch (error) {
            throw new Error(`JSON syntax error. Cannot read JSON file at ${pathToIncludesFile}.`);
        }
        //create includes if not exists
        if (!Array.isArray(includesContent.includes)) {
            includesContent.includes = [];
        }
        //remove existing common js
        includesContent.includes = includesContent.includes.filter(path => {
            //@todo second condition is to be removed
            return !((new RegExp(`^${Config.COMMON_FOLDER_NAME}`, 'i')).test(path) || (new RegExp(`^common`, 'i')).test(path))
        })
        //get all the files and paths. Do this asynchronously
        return util.promisify(glob)(commonFolderPath + '/**/*.js').then(files => {
            files.forEach(filePath => {
                //get relative file path from includes folder
                const filePathRelative = relative(join(commonFolderPath, '..'), filePath);
                //check if file exists in includes file, if not append
                if (-1 === includesContent.includes.findIndex(el => el === filePathRelative)) {
                    includesContent.includes.unshift(filePathRelative);
                }
                /**
                 * @todo add warning content on top of js file
                 */

            });
            //write the edited into json
            writeFileSync(pathToIncludesFile, JSON.stringify(includesContent, null, 2));
            Log.info(`-> js files added to includes.json of ${designFolderName}`)
        });

    },

    createZip: async function () {
        //clean dist folder
        await util.promisify(rimraf)(Config.DIST_FOLDER);
        await util.promisify(mkdir)(Config.DIST_FOLDER);

        // create a file to stream archive data to.
        let output = createWriteStream(Config.DIST_FOLDER + '/Archive.zip');
        let archive = archiver('zip', {
            zlib: { level: 9 } // Sets the compression level.
        });

        let zippingProcess = new Promise((resolve, reject) => {
            // 'close' event is fired only when a file descriptor is involved
            output.on('close', function () {
                resolve(`Archive created`);
            });
            output.on('end', function () {
                Log.info('Data has been drained');
                resolve(`Archive created`);
            });
            archive.on('warning', function (err) {
                if (err.code === 'ENOENT') {
                    Log.error(err.message)
                } else {
                    throw err;
                }
            });
            archive.on('error', function (err) {
                reject(`stderr: ${err.message}`);
                throw err;
            });

            // pipe archive data to the file
            archive.pipe(output);
            //archive directories
            let fefFolderList = readdirSync(Config.FEF_FOLDER).filter(itemName => lstatSync(join(Config.FEF_FOLDER, itemName)).isDirectory());
            for (const fefFolder of fefFolderList) {
                archive.directory(`${Config.FEF_FOLDER}/${fefFolder}`, fefFolder);
            }
            // finalize the archive (ie we are done appending files but streams have to finish yet)
            // 'close', 'end' or 'finish' may be fired right after calling this method so register to them beforehand
            archive.finalize();
        });

        return zippingProcess;
    }
};

const Log = {
    done: function(message) {
        console.log(chalk['green'](message));
    },

    error: function (message) {
        console.log(chalk.white.bgRed(message));
    },

    info: function (message) {
        console.log(chalk['gray'](message));
    },

    completed: function (message) {
        console.log(chalk.black.bgGreenBright(message));
    }
}

/**
 * Run the build process
 */
Builder.archive();
