const Config = {
    FEF_FOLDER: __dirname + '/src/fef',
    SRC_FOLDER: __dirname ,
    DIST_FOLDER: __dirname + '/dist',
    COMMON_FOLDER_NAME: `common-autogenerated-new`
};

const esprima = require('esprima');
const fs = require('fs');
const _ = require('lodash');
const path = require('path');
const glob = require('glob');
const util = require('util');
const rimraf = require("rimraf");
const chalk = require('chalk');
const archiver = require('archiver');

const Builder = {

    /**
     * associative array which holds data about common files
     */
    commonFileObjectsArr: {},

    /**
     * Driver function
     */
    archive: function (){

        Log.done('Starting FEF build process...');

        Builder.analyseCommonFiles();

        if(Builder.commonFileObjectsArr){

            fs.readdirSync(Config.FEF_FOLDER).forEach(folderName => {//iterate over custom object folders

                var coFolderPath = path.join(Config.FEF_FOLDER,folderName);
                
                if(fs.lstatSync(coFolderPath).isDirectory() && folderName.charAt(0) === '$'){//check whether custom object folder or not
                
                    var copyFiles = Builder.findCopyFiles(coFolderPath);

                    Builder.copyFilesToDestination(copyFiles,coFolderPath);

                }
            });
        }

        Builder.createZip().then(() => {
            Log.completed('Success! Archive.zip created in "dist" folder.')
        })
        .catch(error => {
            Log.error(`!PROCESS HALTED!. Please rectify the error. ${error}`)
        })
    },


    /**
     * analyse all common files and update commonFileObjectsArr global array
     */
    analyseCommonFiles: function (){

        const commonFilesArr = glob.sync(Config.SRC_FOLDER + '/src/{*.js,!(fef)/**/*.js}');//retrieve all .js except files inside fef folder
        
        commonFilesArr.forEach(file => {
            Builder.commonFileObjectsArr[file] = Builder.analyseFile(file);//get file object with declared, undeclared and file path
        });

        Object.keys(Builder.commonFileObjectsArr).forEach(fileObj => {

            if(Builder.commonFileObjectsArr[fileObj].undeclared){
                
                Object.keys(Builder.commonFileObjectsArr).forEach(anyFileObj => {//compare each file with other common files
                    let intersect = _.intersection(Builder.commonFileObjectsArr[fileObj].undeclared,Builder.commonFileObjectsArr[anyFileObj].declared);//check whether undeclared identifiers are declared in other files
                    if(intersect.length > 0){//if intersect add that file in to imports
                        if (Builder.commonFileObjectsArr[fileObj].imports === undefined) Builder.commonFileObjectsArr[fileObj].imports = [];
                        Builder.commonFileObjectsArr[fileObj].imports.push(anyFileObj);
                    }
                });
            }
        });

        Object.keys(Builder.commonFileObjectsArr).forEach(fileObj => {//moving this in to first loop cant be done, bcz we have to wait until all files are finished in first loop
            if(Builder.commonFileObjectsArr[fileObj].imports){//If there is no imports why we should have transitive imports ??
                Builder.commonFileObjectsArr[fileObj].transitiveImports = [];//if import array is not empty check recursively for transitive imports
                Builder.findTransitiveRecursively(Builder.commonFileObjectsArr[fileObj].imports,Builder.commonFileObjectsArr[fileObj].transitiveImports,Builder.commonFileObjectsArr);
            }
        });
    },


    /**
     * analyse the content of one common file
     * @param file
     */
    analyseFile: function (file){

        var declarations = [];

        var content = fs.readFileSync(file,'utf-8');//read file content

        try{
            var ast = esprima.parse(content);//get AST tree using esprima
        }catch(error){
            throw new Error(`Cannot parse ${file} content`);
        }

        declarations = Builder.findDeclaration(ast.body);
        console.log(file,declarations.undeclared);

        return { filepath: file, declared: declarations.declared , undeclared: declarations.undeclared};

    },


    /**
     * recursive function which traverse down the AST tree
     * @param node 
     * @param func callback function of recursive 
     */
    traverse: function (node, func) {

        func(node);
        for (var key in node) {
            if (node.hasOwnProperty(key)) {
                var child = node[key];
                //check child node is an object or not,  null may refer as a object too
                if (typeof child === 'object' && child !== null) {
                    //check child is contain array of nodes
                    if (Array.isArray(child)) {
                        //check each node at the same level
                        child.forEach(function(node) {
                            Builder.traverse(node, func);//call recursive if node has childrens
                        });
                    } else {
                        Builder.traverse(child, func);
                    }
                }
            }
        }
    },


    /**
     * find declared and undeclared identifiers of given common file
     * @param astBody AST of one common file
     */
    findDeclaration: function (astBody){

        var identifiersArr = {};
        var declaredArr = [];
        var undeclaredArr = [];

        var addStatsEntry = function(identifier){
            if(!identifiersArr[identifier]){//initiate object with identifier as key
                identifiersArr[identifier] = { calls:0, declared:false };
            }
        };

        Builder.traverse(astBody, function(node){//callback of recursive function
            if(node.type === 'ClassDeclaration'){
                addStatsEntry(node.id.name);
                identifiersArr[node.id.name].declared = true;
            }else if(node.type === 'FunctionDeclaration'){
                addStatsEntry(node.id.name);
                identifiersArr[node.id.name].declared = true; 
            }else if(node.type === 'VariableDeclaration'){//filter all type of variables
                Object.values(node.declarations).filter(constant => {
                    addStatsEntry(constant.id.name);
                    identifiersArr[constant.id.name].declared = true;
                });
            }else if(node.type === 'CallExpression' && node.callee.type === 'Identifier'){
                addStatsEntry(node.callee.name);
                identifiersArr[node.callee.name].calls++;//check this identifier called in some where
            }else if(node.type === 'MemberExpression' && node.object.type === 'Identifier'){
                addStatsEntry(node.object.name);
                identifiersArr[node.object.name].calls++;//check this identifier called in some where
                // undeclaredArr.push(node.object.name);
            }
        });

        Object.keys(identifiersArr).forEach(identifier => {
            if(identifiersArr[identifier].declared){
                declaredArr.push(identifier);//if identifier is declared push in to declared array
            }else{
                undeclaredArr.push(identifier);//if identifier is undeclared push in to undeclared array
            }
        });

        return { declared: declaredArr, undeclared: undeclaredArr };
    },


    /**
     * recursive function to find transitive imports
     * @param importArr import array of one common file object
     * @param transitiveArr transitive array of one common file object
     * @param fileObjectsArr commmon file objects associative array
     */
    findTransitiveRecursively: function (importArr, transitiveArr, fileObjectsArr){

        importArr.forEach(arrItem => {
            transitiveArr.push(arrItem);
            if(fileObjectsArr[arrItem].imports){//If there is no imports why we should have transitive imports ??
                Builder.findTransitiveRecursively(fileObjectsArr[arrItem].imports,transitiveArr, fileObjectsArr);//call recursive if imports array is not empty
            }
        });

    },

    /**
     * return array of copy files for a given custom object
     * @param coFolderPath folder path of one custom object
     */
    findCopyFiles : function(coFolderPath){

        var copyFilesArr = [];
        var coIdentifiers = Builder.findCustomObjectIdentifiers(glob.sync(coFolderPath+'/source/{behaviors,includes/js}/**/*.js'));//retrieve only .js inside /behaviour and /includes/js folders

        Object.keys(Builder.commonFileObjectsArr).forEach(key => {
            let intersect = _.intersection(Builder.commonFileObjectsArr[key].declared, coIdentifiers);//check custom object includes any content of a common file
            if(intersect.length > 0){
                if(!Builder.commonFileObjectsArr[key].imports){
                    copyFilesArr.push(Builder.commonFileObjectsArr[key].filepath)
                }else{
                    copyFilesArr.push(Builder.commonFileObjectsArr[key].filepath,Builder.commonFileObjectsArr[key].transitiveImports);
                }
            }
        });

        return _.uniq(_.flattenDeep(copyFilesArr));
    },

    /**
     * return array of identifiers for files in one custom object
     * @param coFilesArr file array of one custom object
     */
    findCustomObjectIdentifiers: function  (coFilesArr){
        
        var tokens = [];
        var identifiers = [];

        coFilesArr.forEach(file => {
            let content = fs.readFileSync(file,'utf-8');//read file content 
            try{
                tokens.push(esprima.tokenize(content));//push tokens in each file to tokens array
            }catch(error){
                throw new Error(`Cannot tokenize ${file} content.`);
            }  
        });

        identifiers = _.flattenDeep(tokens).filter(token => {//filter only identifiers by tokens
            return token.type === 'Identifier';
        });

        var uniqueIdentifiers = _.uniqBy(identifiers, id => {//get only unique identifiers
            return id.value;
        });

        var coIdentifiers = uniqueIdentifiers.map(id => id.value);//get only value of the identifiers

        return coIdentifiers;
    },

    /**
     * copy relevant common files in to custom object folders while updating relative path in include.js
     * @param copyFilesArr array of files should be copied
     * @param coFolderPath destination custom object folder
     */
    copyFilesToDestination: function (copyFilesArr,coFolderPath){

        // console.log(coFolderPath,copyFilesArr);

        const pathToIncludesFile = path.join(coFolderPath, 'source', 'server', 'includes.json');
        try {
            var includesContent = JSON.parse(fs.readFileSync(pathToIncludesFile));
        } catch (error) {
            throw new Error(`JSON syntax error. Cannot read JSON file at ${pathToIncludesFile}.`);
        }

        if (!Array.isArray(includesContent.includes)) {//create includes if not exists
            includesContent.includes = [];
        }

        includesContent.includes = includesContent.includes.filter(path => {//remove existing common js
            //@todo third condition is to be removed
            return !((new RegExp(`^${Config.COMMON_FOLDER_NAME}`, 'i')).test(path) || (new RegExp(`^common-autogenerated-25012019`, 'i')).test(path) || (new RegExp(`^common`, 'i')).test(path));
        });

        var targetFolder = path.join(coFolderPath,'source','includes',Config.COMMON_FOLDER_NAME);
        rimraf.sync(targetFolder);//remove existing folder
        fs.mkdirSync(targetFolder);
        Log.info(`-> copying commons to ${coFolderPath}`);

        copyFilesArr.forEach(file => {

            var targetFile = path.join(targetFolder,file.substring(file.lastIndexOf('/')));
            try{
                fs.copyFileSync(file, targetFile);
            }catch (error){
                throw new Error(`Cannot copy file to ${targetFile}.`);
            }
            
            const filePathRelative = path.join(Config.COMMON_FOLDER_NAME, file.substring(file.lastIndexOf('/')));//get relative file path from includes folder
        
            if (-1 === includesContent.includes.findIndex(el => el === filePathRelative)) {//check if file exists in includes file, if not append
                includesContent.includes.unshift(filePathRelative);
            }
            /**
             * @todo add warning content on top of js file
             */
        });
        Log.info(`-> completed copying to ${coFolderPath}`);

        fs.writeFileSync(pathToIncludesFile, JSON.stringify(includesContent, null, 2)); //write the edited into json
        
        Log.info(`-> js files added to includes.json of ${coFolderPath}`);
    },

    createZip: async function () {
        //clean dist folder
        await util.promisify(rimraf)(Config.DIST_FOLDER);
        await util.promisify(fs.mkdir)(Config.DIST_FOLDER);

        // create a file to stream archive data to.
        let output = fs.createWriteStream(Config.DIST_FOLDER + '/Archive.zip');
        let archive = archiver('zip', {
            zlib: { level: 9 } // Sets the compression level.
        });

        let zippingProcess = new Promise((resolve, reject) => {
            // 'close' event is fired only when a file descriptor is involved
            output.on('close', function () {
                resolve(`Archive created`);
            });
            output.on('end', function () {
                Log.info('Data has been drained');
                resolve(`Archive created`);
            });
            archive.on('warning', function (err) {
                if (err.code === 'ENOENT') {
                    Log.error(err.message)
                } else {
                    throw err;
                }
            });
            archive.on('error', function (err) {
                reject(`stderr: ${err.message}`);
                throw err;
            });

            // pipe archive data to the file
            archive.pipe(output);
            //archive directories
            let fefFolderList = fs.readdirSync(Config.FEF_FOLDER).filter(itemName => fs.lstatSync(path.join(Config.FEF_FOLDER, itemName)).isDirectory());
            for (const fefFolder of fefFolderList) {
                archive.directory(`${Config.FEF_FOLDER}/${fefFolder}`, fefFolder);
            }
            // finalize the archive (ie we are done appending files but streams have to finish yet)
            // 'close', 'end' or 'finish' may be fired right after calling this method so register to them beforehand
            archive.finalize();
        });

        return zippingProcess;
    }

}

const Log = {
    done: function(message) {
        console.log(chalk['green'](message));
    },

    error: function (message) {
        console.log(chalk.white.bgRed(message));
    },

    info: function (message) {
        console.log(chalk['gray'](message));
    },

    completed: function (message) {
        console.log(chalk.black.bgGreenBright(message));
    }
}

Builder.archive();