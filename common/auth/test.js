const Config = {
    FEF_FOLDER: __dirname + '/src/fef',
    SRC_FOLDER: __dirname + '/src/common',
    DIST_FOLDER: __dirname + '/dist',
    COMMON_FOLDER_NAME: `common-autogenerated-25012019`
};

const COMMON_FILE_PATH = '/Users/imadhushanka/Desktop/Archive/src/common';
const CO_FILE_PATH = '/Users/imadhushanka/Desktop/Archive/src/fef';

const esprima = require('esprima');
const fs = require('fs');
const _ = require('lodash');
var path = require('path');

function findCustomObjectIdentifiers(coFilesArr){//return array of identifiers in one custom object
     
    var tokens = [];
    var identifiers = [];

    coFilesArr.forEach(file => {
        const content = fs.readFileSync(file,'utf-8');//read file content 

        try{
            tokens.push(esprima.tokenize(content));//push tokens in each file to tokens array
        }catch(error){
            throw new Error(`Cannot tokenize ${file} content.`);
        }  
    });

    identifiers = _.flattenDeep(tokens).filter(token => {//filter only identifiers by tokens
        return token.type === 'Identifier';
    });

    const uniqueIdentifiers = _.uniqBy(identifiers, id => {//get only unique identifiers
        return id.value;
    });

    const coIdentifiers = uniqueIdentifiers.map(id => id.value);//get only value of the identifiers
    return coIdentifiers;

}

function analyseCommonFiles(commonFilesArr){//return array of common file objects with transitive imports and file path

    var fileObjectsArr = {};
    
    commonFilesArr.forEach(file => {
        fileObjectsArr[file] = analyseFile(file);//get file object with declared, undeclared and file path
    });

    Object.keys(fileObjectsArr).forEach(fileObj => {
        Object.keys(fileObjectsArr).forEach(anyFileObj => {//compare each file with other common files
            const intersect = _.intersection(fileObjectsArr[fileObj].undeclared,fileObjectsArr[anyFileObj].declared);//check whether undeclared identifiers are declared in other files
            if(intersect.length > 0){
                if (fileObjectsArr[fileObj].imports === undefined) fileObjectsArr[fileObj].imports = [];
                fileObjectsArr[fileObj].imports.push(anyFileObj);
            }
        });
    });

    Object.keys(fileObjectsArr).forEach(fileObj => {
        if(fileObjectsArr[fileObj].imports){//If there is no imports why we should have transitive imports ??
            fileObjectsArr[fileObj].transitiveImports = [];
            findTransitiveRecursively(fileObjectsArr[fileObj].imports,fileObjectsArr[fileObj].transitiveImports,fileObjectsArr);
        }
    });
    
    return fileObjectsArr;
}

function analyseFile(file){

    var declared = [];
    var undeclared = [];

    const content = fs.readFileSync(file,'utf-8');//read file content

    try{
        var ast = esprima.parse(content);//get AST tree using esprima
    }catch(error){
        throw new Error(`Cannot parse ${file} content`);
    }

    declared = findDeclared(ast.body);
    undeclared = findUndeclared(ast.body);

    return { filepath: file, declared: declared, undeclared: undeclared};

}

function traverse(node, func) {//recursive function which traverse down the AST tree

    func(node);
    for (var key in node) {
        if (node.hasOwnProperty(key)) {
            var child = node[key];
            //check child node is an object or not,  null may refer as a object too
            if (typeof child === 'object' && child !== null) {
                //check child is contain array of nodes
                if (Array.isArray(child)) {
                    //check each node at the same level
                    child.forEach(function(node) {
                        traverse(node, func);
                    });
                } else {
                    traverse(child, func);
                }
            }
        }
    }
}

function findUndeclared(astBody){//find undeclared identifiers of given file

    var identifiersArr = {};
    var undeclaredArr = [];

    var addStatsEntry = function(identifier){
        if(!identifiersArr[identifier]){//initiate object with identifier as key
            identifiersArr[identifier] = {calls:0, declarations:false };
        }
    };

    traverse(astBody, function(node){//callback of recursive function
        if(node.type === 'ClassDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declarations=true;
        }else if(node.type === 'FunctionDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declarations=true; 
        }else if(node.type === 'VariableDeclaration' && node.kind === 'const'){//filter only consts
            Object.values(node.declarations).filter(constant => {
                addStatsEntry(constant.id.name);
                identifiersArr[constant.id.name].declarations=true;
            });
        }else if(node.type === 'CallExpression' && node.callee.type === 'Identifier'){
            addStatsEntry(node.callee.name);
            identifiersArr[node.callee.name].calls++;//check whether this is returns only undeclaed ones or not and whether have to check call times too
            if(!identifiersArr[node.callee.name].declarations){//&&identifiersArr[node.callee.name].calls>0
                undeclaredArr.push(node.callee.name);//push only undeclared identifiers to array
            }
        }
    });

    return undeclaredArr;

}

function findDeclared(astBody){//find declared functions, constants and variables in a common file

    var declaredArr = [];

    Object.values(astBody).filter(node => {//always top levels reside in the first depth
   
        if(node.type === 'ClassDeclaration' || node.type === 'FunctionDeclaration'){//filter declared classes and functions

            declaredArr.push(node.id.name);

        }else if(node.type === 'VariableDeclaration' && node.kind === 'const'){

            Object.values(node.declarations).filter(constant => {
                declaredArr.push(constant.id.name);
            });
        }
    
    });

    return declaredArr;
}

function findTransitiveRecursively(importArr, transitiveArr, fileObjectsArr){//recursive function to find transitive imports
    importArr.forEach(arrItem => {
        transitiveArr.push(arrItem);
        if(fileObjectsArr[arrItem].imports){//If there is no imports why we should have transitive imports ??
            findTransitiveRecursively(fileObjectsArr[arrItem].imports,transitiveArr, fileObjectsArr);
        }
    });
}

console.log(__dirname);


function getCOFolders(){
    var coFolders = [];
    fs.readdirSync(Config.FEF_FOLDER).forEach(folderName => {
        let coFolderPath = join(Config.FEF_FOLDER,folderName);
        if(fs.lstatSync(coFolderPath).isDirectory() && folderName.charAt(0) === '$'){
            // return coFolderPath;
            console.log(coFolderPath);
            // console.log(glob.sync(coFolderPath+'/source/{behaviors,includes/js}/**/*.js'));
        }
    });

    // return coFolders;
}

// getCOFolders();

// function processCOFolder(folderName){
//     try{
//         let coFolderPath = join(Config.FEF_FOLDER,folderName);
//         if(fs.lstatSync(coFolderPath).isDirectory() && folderName.charAt(0) === '$'){
//             return coFolderPath;
//         }
//     }catch( error){
//         throw new Error(`!Error processing ${folderName} - ${error}`);
//     }
// }


// const arr = analyseCommonFiles(getFiles(COMMON_FILE_PATH));
// console.log(arr);

// const arr2 = findCustomObjectIdentifiers(getFiles(CO_FILE_PATH));
// console.log(arr2);
















