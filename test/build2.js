const Config = {
    FEF_FOLDER: __dirname + '/src/fef',
    SRC_FOLDER: __dirname ,
    DIST_FOLDER: __dirname + '/dist',
    COMMON_FOLDER_NAME: `common-autogenerated-new`
};

const file = Config.SRC_FOLDER+'/src/common/user/authentication.js';

const glob = require('glob');
const esprima = require( "esprima" );
const fs = require('fs');

const content = fs.readFileSync(file,'utf-8');//get file content
var ast = esprima.parse(content);//get AST tree using esprima


function traverse(node, func) {

    func(node);
    for (var key in node) {
        console.log("key",key);
        if (node.hasOwnProperty(key)) {
            var child = node[key];
            console.log("child",child);
            //check child node is an object or not,  null may refer as a object too
            if (typeof child === 'object' && child !== null) {
                //check child is contain array of nodes
                if (Array.isArray(child)) {
                    //check each node at the same level
                    child.forEach(function(node) {
                        traverse(node, func);//call recursive if node has childrens
                    });
                } else {
                    traverse(child, func);
                }
            }
        }
    }
}

var arr = findDeclaration(ast.body);
console.log(arr);


function findDeclaration(astBody){

    var identifiersArr = {};
    var declaredArr = [];
    var undeclaredArr = [];

    var addStatsEntry = function(identifier){
        if(!identifiersArr[identifier]){//initiate object with identifier as key
            identifiersArr[identifier] = { calls:0, declared:false };
        }
    };

    Builder.traverse(astBody, function(node){//callback of recursive function
        if(node.type === 'ClassDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declared = true;
        }else if(node.type === 'FunctionDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declared = true; 
        }else if(node.type === 'VariableDeclaration' && node.kind === 'const'){//filter only constants
            Object.values(node.declarations).filter(constant => {
                addStatsEntry(constant.id.name);
                identifiersArr[constant.id.name].declared = true;
            });
        }else if(node.type === 'CallExpression' && node.callee.type === 'Identifier'){
            addStatsEntry(node.callee.name);
            identifiersArr[node.callee.name].calls++;//check this identifier called in some where
        }
    });

    Object.keys(identifiersArr).forEach(identifier => {
        if(identifiersArr[identifier].declared){
            declaredArr.push(identifier);//if identifier is declared push in to declared array
        }else{
            undeclaredArr.push(identifier);//if identifier is undeclared push in to undeclared array
        }
    });

    return { declared: declaredArr, undeclared: undeclaredArr };
}





if(node.type === 'MemberExpression' && node.object.type === 'Identifier'){
    
    undeclaredArr.push(node.object.name);
}