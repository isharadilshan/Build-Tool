const esprima = require('esprima');
const fs = require('fs-extra');
const glob = require('glob');

const Config = {
    FEF_FOLDER: __dirname + '/src/fef',
    SRC_FOLDER: __dirname ,
    DIST_FOLDER: __dirname + '/dist',
    COMMON_FOLDER_NAME: `common-autogenerated-new`
};

const file = '/Users/imadhushanka/Documents/Build-Tool/common/test.js';
var tokens = [];
const content = fs.readFileSync(file,'utf-8');
var ast = esprima.parseScript(content);

calt(ast);

function traverse(node, func) {

    func(node);
    for (var key in node) {
        console.log("key",key);
        if (node.hasOwnProperty(key)) {
            var child = node[key];
            console.log("child",child);
            //check child node is an object or not,  null may refer as a object too
            if (typeof child === 'object' && child !== null) {
                //check child is contain array of nodes
                if (Array.isArray(child)) {
                    //check each node at the same level
                    child.forEach(function(node) {
                        traverse(node, func);//call recursive if node has childrens
                    });
                } else {
                    traverse(child, func);
                }
            }
        }
    }
}

function calt(astBody){

    var identifiersArr = {};
    var declaredArr = [];
    var undeclaredArr = [];

    var addStatsEntry = function(identifier){
        if(!identifiersArr[identifier]){//initiate object with identifier as key
            identifiersArr[identifier] = { calls:0, declared:false };
        }
    };

    traverse(astBody, function(node){//callback of recursive function
        if(node.type === 'ClassDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declared = true;
        }else if(node.type === 'FunctionDeclaration'){
            addStatsEntry(node.id.name);
            identifiersArr[node.id.name].declared = true; 
        }else if(node.type === 'VariableDeclaration' && node.kind === 'const'){//filter only constants
            Object.values(node.declarations).filter(constant => {
                addStatsEntry(constant.id.name);
                identifiersArr[constant.id.name].declared = true;
            });
        }else if(node.type === 'CallExpression' && node.callee.type === 'Identifier'){
            addStatsEntry(node.callee.name);
            identifiersArr[node.callee.name].calls++;//check this identifier called in some where
        }
    });
}
